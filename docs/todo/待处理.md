## 刷题

###  1.现在有十万个单词，请你找出重复次数最多的十个。

```java
private  String str = "Look to the skies above London and you'll see the usual suspects rainclouds, plane and pigeons. But by the end of the year, you might just see something else.";


	/**
	 *
	 * 1.现在有十万个单词，请你找出重复次数最多的十个。
	 *
	 */
	private void getWordAsMost() {

		long start = System.currentTimeMillis();
		//剔除空格、逗号、和引号
		str = str.replace('\'', ' ');//将'号用空格替换
		str = str.replace(',', ' ');//将逗号用空格替换
		str = str.replace('.', ' ');//将句号用空格替换

		// “\\s+”代表一个或多个空格，是正则表达式
		String[] strings = str.split("\\s+");

		Map<String, Integer> map = new HashMap<>(16);
		//存储每个不重复的单词
		List<String> list = new ArrayList<String>();

		for(String s : strings){
			//如果map中已经包含该单词，则将其个数+1
			if(map.containsKey(s)){
				int x = map.get(s);
				x++;
				map.put(s, x);
			}else{
				//如果map中没用包含该单词，代表该单词第一次出现，则将其放入map并将个数设置为1
				map.put(s, 1);
				//将其添加到list中，代表它是一个新出现的单词
				list.add(s);
			}
		}

		//记录出现次数最多的那个单词的出现次数
		int max=0;
		//记录出现次数最多的那个单词的值
		String maxString = null;
		/*
		 * 从list中取出每个单词，在map中查找其出现次数
		 * 并没有真正排序，而只是记录下出现次数最多的那个单词
		 */
		for(String s : list){
			int x = map.get(s);
			if(x>max){
				maxString = s;
				max = x;
			}
		}

		System.out.println(maxString);

		long end = System.currentTimeMillis();

		System.out.println("共耗时：" + (end - start) + "毫秒");

	}
```

### Bean 工具

```java

    /**
     * Bean工具
     */
    public static class BeanUtil {

        /**
         * 将Bean复制到Map里面去。
         * @param bean
         * @param map
         */
        public static void bean2map(Object bean, Map map) {
            BeanMap beanMap = new BeanMap(bean);
            for (Object key : beanMap.keySet()) {
                Object value = beanMap.get(key);
                if (value == null )
                    continue;
                map.put(key.toString(), value);
            }
        }

    /*    public static void main(String[] args) {
            Class cl = MapUserArea.class;
            for (Field f : cl.getDeclaredFields()) {
                try {
                    Method m = cl.getMethod("get"+captureName(f.getName()));
                    System.out.println(m.getAnnotation(Column.class).name()+" "+f.getName() + ",");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }*/

        /**
         * 将首字母大写
         * @param name
         * @return
         */
        public static String captureName(String name) {
            name = name.substring(0, 1).toUpperCase() + name.substring(1);
            return  name;

        }
        /**
         * 复制sour里属性不为空的值到obje为空的属性
         *
         * @param obje
         *            目标实体类
         * @param sour
         *            源实体类
         * @param isCover
         *            是否保留obje类里不为null的属性值(true为保留源值，属性为null则赋值)
         * @return obje
         */
        public static Object Copy(Object obje, Object sour, boolean isCover) {
            Field[] fields = sour.getClass().getDeclaredFields();
            for (int i = 0, j = fields.length; i < j; i++) {
                String propertyName = fields[i].getName();
                Object propertyValue = getProperty(sour, propertyName);
                if (isCover) {
                    if (getProperty(obje, propertyName) == null && propertyValue != null) {
                        Object setProperty = setProperty(obje, propertyName, propertyValue);
                    }
                } else {
                    Object setProperty = setProperty(obje, propertyName, propertyValue);
                }

            }
            return obje;
        }
        /**
         * 复制sour里属性不为空的值到obj里并相加
         *
         * @param obj
         *            目标实体类
         * @param sour
         *            源实体类
         * @param isCover
         *
         * @return obj
         */
        public static Object CopyAndAdd(Object obj, Object sour, boolean isCover) {
            Field[] fields = sour.getClass().getDeclaredFields();
            for (int i = 0, j = fields.length; i < j; i++) {
                String propertyName = fields[i].getName();
                Object sourPropertyValue = getProperty(sour, propertyName);
                Object objPropertyValue = getProperty(obj, propertyName);
                if (isCover) {
                    if ( objPropertyValue== null && sourPropertyValue != null) {
                        Object setProperty = setProperty(obj, propertyName, sourPropertyValue);
                    }else if ( objPropertyValue != null && sourPropertyValue == null) {
                        Object setProperty = setProperty(obj, propertyName, objPropertyValue);
                    }else if ( objPropertyValue != null && sourPropertyValue != null) {
                        Object setProperty = setProperty(obj, propertyName, ((int)sourPropertyValue)+(int)objPropertyValue);
                    }
                }

            }
            return obj;
        }


        /**
         * 得到值
         *
         * @param bean
         * @param propertyName
         * @return
         */
        private static Object getProperty(Object bean, String propertyName) {
            Class clazz = bean.getClass();
            try {
                Field field = clazz.getDeclaredField(propertyName);
                Method method = clazz.getDeclaredMethod(getGetterName(field.getName()), new Class[] {});
                return method.invoke(bean, new Object[] {});
            } catch (Exception e) {
            }
            return null;
        }

        /**
         * 给bean赋值
         *
         * @param bean
         * @param propertyName
         * @param value
         * @return
         */
        private static Object setProperty(Object bean, String propertyName, Object value) {
            Class clazz = bean.getClass();
            try {
                Field field = clazz.getDeclaredField(propertyName);
                Method method = clazz.getDeclaredMethod(getSetterName(field.getName()), new Class[] { field.getType() });
                return method.invoke(bean, new Object[] { value });
            } catch (Exception e) {
            }
            return null;
        }

        /**
         * 根据变量名得到get方法
         *
         * @param propertyName
         * @return
         */
        private static String getGetterName(String propertyName) {
            String method = "get" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
            return method;
        }

        /**
         * 得到setter方法
         *
         * @param propertyName
         *            变量名
         * @return
         */
        private static String getSetterName(String propertyName) {
            String method = "set" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
            return method;
        }

        public static void main(String[] args) {
        }

        /**
         * 父类集合转成子类集合集合通用方法(子类集合接收父类集合)
         * @param list 父类集合
         * @param <T> 子类
         * @param <E> 父类
         * @return
         */
        public static <T,E> List<T> chang2ChildClassList(List<E> list) {
            List<T> alist = new ArrayList<>();
            for (E  o : list) {
                alist.add((T)o);
            }
            return alist;

        }


        /**
         *
         * map转str
         * @param map
         * @return
         */
        public static String getMapToString(Map<String, String> map) {
            Set<String> keySet = map.keySet();
            //将set集合转换为数组
            String[] keyArray = keySet.toArray(new String[keySet.size()]);
            //给数组排序(升序)
            Arrays.sort(keyArray);
            //因为String拼接效率会很低的，所以转用StringBuilder。博主会在这篇博文发后不久，会更新一篇String与StringBuilder开发时的抉择的博文。
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < keyArray.length; i++) {
                // 参数值为空，则不参与签名 这个方法trim()是去空格
                if (map.get(keyArray[i]).trim().length() > 0) {
                    sb.append(keyArray[i]).append("=").append(map.get(keyArray[i]).trim());
                }
                if (i != keyArray.length - 1) {
                    sb.append("&");
                }
            }
            return sb.toString();
        }
    }
```



### Json格式化

```java

	private static final SerializerFeature[] features = {
			SerializerFeature.WriteMapNullValue,
			// 输出空置字段
			// SerializerFeature.WriteNullListAsEmpty,
			// // list字段如果为null，输出为[]，而不是null
			// SerializerFeature.WriteNullNumberAsZero,
			// // 数值字段如果为null，输出为0，而不是null
			// SerializerFeature.WriteNullBooleanAsFalse,
			// // Boolean字段如果为null，输出为false，而不是null
			// SerializerFeature.WriteNullStringAsEmpty,
			// // 字符类型字段如果为null，输出为""，而不是null
			SerializerFeature.WriteDateUseDateFormat
			// 日期格式化yyyy-MM-dd HH:mm:ss
	};

	public static String toJson(Object object) {
		return JSON.toJSONString(object, features);
	}
```

### BeanCopy



```java

	/**
	 * 8.benaCopy 使用
	 */
	@Override
	public void getBeanMapCopy(){

		//1. 对象Copy
		CustomerVO customerVO = new CustomerVO();
		CustomerPO customerPO = new CustomerPO();
		customerPO.setCustomerNo("A681");
		customerPO.setCustomerId(100);
		customerPO.setCustomerName("杭州");

		//bean 复制方法一 copyProperties(数据源，目标源)；
		BeanUtils.copyProperties(customerPO, customerVO);
		System.out.println(customerVO.getCustomerName());

		//bean 复制方法二
		BeanCopier copier = BeanCopier.create(customerPO.getClass(), customerVO.getClass(), false);
		copier.copy(customerPO, customerVO, null);
		System.out.println(customerVO.getCustomerName());

		//bean 复制方法三
//		PropertyUtils.copyProperties(customerPO, customerVO);

		/**
		 * 说明
		 * 	在性能方面，Spring BeanUtils和Cglib BeanCopier表现比较不错，
		 * 	Apache PropertyUtils、Apache BeanUtils以及Dozer则表现的很不好。
		 * 所以，如果考虑性能情况的话，建议大家不要选择Apache PropertyUtils、Apache BeanUtils以及Dozer等工具类
		 */
		//2. 对象转换为map
		Map<String, Object> map = new HashMap<>(16);
		BeanUtil.bean2map(customerVO, map);
		for (Map.Entry<String, Object> stringObjectEntry : map.entrySet()) {
			String key= stringObjectEntry.getKey();
			Object value= stringObjectEntry.getValue();
			System.out.println(key);
		}
		//3.list 进行copy 处理


	}
```



### 获取最后一个元素

```java
	/**
	 * 获取list中存放的最后一个元素
	 *
	 * @param list
	 * @param <T>
	 * @return
	 */
	public static <T> T getLastElement(List<T> list) {
		return list.get(list.size() - 1);
	}
```





### 冒泡排序

```java

    /**
     * 冒泡排序法
     */
    @Test
    void bubblingSort(int[] arrInts){

        System.out.println(Arrays.toString(arrInts));
        int temp=0;

        //外层循环 判断需要走多少次
        for (int i = 0; i < arrInts.length; i++) {

            for (int j = 0; j <arrInts.length-1-i ; j++) {
                //从大到小排序
                //将> 改为<则为从小到大排序

                if (arrInts[j+1]>arrInts[j]){
                    temp=arrInts[j];
                    arrInts[j]=arrInts[j+1];
                    arrInts[j+1]=temp;
                }
            }
        }

        boolean flag = false;
        //外层循环 判断需要走多少次 优化
        for (int i = 0; i < arrInts.length; i++) {

            for (int j = 0; j < arrInts.length - 1 - i; j++) {
                //从大到小排序
                //将> 改为<则为从小到大排序

                if (arrInts[j + 1] > arrInts[j]) {
                    temp = arrInts[j];
                    arrInts[j] = arrInts[j + 1];
                    arrInts[j + 1] = temp;
                    flag = true;
                }
            }
            if (flag) {
                break;
            }
        }

    }
```

