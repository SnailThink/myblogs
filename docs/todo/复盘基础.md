 ## 复盘基础内容



## 1.SpringBoot



#### 1.SpringBoot自动装配




- ```java
  @SpringBootApplication 标注是一个springboot的应用 
  ```

- ```java
  @SpringBootConfiguration   springboot的配置
  @Configuration   spring的配置类
  @Component   说明这也是一个spring的组件
  @EnableAutoConfiguration   开启自动配置
  @AutoConfigurationPackage  自动配置包
  @Import(AutoConfigurationPackages.Registrar.class)  导入选择器
  @Import(AutoConfigurationImportSelector.class)   导入选择器
  List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes); 获取所有的配置
  ```
  
- ```java
  //获取所有的配置
  protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
     List<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
           getBeanClassLoader());
     Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you "
           + "are using a custom packaging, make sure that file is correct.");
     return configurations;
  }
  
  protected Class<?> getSpringFactoriesLoaderFactoryClass() {
  		return EnableAutoConfiguration.class;
  	}
  ```
  
- META-INF/spring.factories  自动配置的核心文件
  

![](https://whcoding.oss-cn-hangzhou.aliyuncs.com/img/20220401182242.png)

spring-factories 存放的都是自动配置类的名称，主程序启动时候就通过注解将自动配置类全部加载，有了这些配置类就省去写配置文件.



[springboot自动装配](https://juejin.cn/post/6939520188823896100)

[springboot原理解析](https://juejin.cn/post/6939470264853889061#heading-19)

#### 2.SpringMVC 初始化流程分析



 ## 2. 集合

 #### 2.2.1 Arraylist 与 LinkedList 区别?

1.  是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；
2. **底层数据结构：** `Arraylist` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。
3. **插入和删除是否受元素位置的影响：** ① **`ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。** 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② **`LinkedList` 采用链表存储，所以对于`add(E e)`方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置`i`插入和删除元素的话（`(add(int index, E element)`） 时间复杂度近似为`o(n))`因为需要先移动到指定位置再插入。**
4. **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList` 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。
5. **内存空间占用：** ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。
6. LinkedList 言插入删除操作很快，但是查询操作很慢



#### 2.2.2. 如何选用集合?

需要排序时选择 `TreeMap`,不需要排序时就选择 `HashMap`,需要保证线程安全就选用 `ConcurrentHashMap`。

当我们只需要存放元素值时，就选择实现`Collection` 接口的集合，需要保证元素唯一时选择实现 `Set` 接口的集合比如 `TreeSet` 或 `HashSet`，不需要就选择实现 `List` 接口的比如 `ArrayList` 或 `LinkedList`，然后再根据实现这些接


#### 2.2.3 HashSet、LinkedHashSet 和 TreeSet 三者的异同

`HashSet` 是 `Set` 接口的主要实现类 ，`HashSet` 的底层是 `HashMap`，线程不安全的，可以存储 null 值；

`LinkedHashSet` 是 `HashSet` 的子类，能够按照添加的顺序遍历；

`TreeSet` 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。



## 3.面向对象

**面向对象的五大基本原则**

**单一职责原则（Single-Responsibility Principle）**

其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。

单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起 变化的原因，以提高内聚性来减少引起变化的原因。

职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响， 从而大大损伤其内聚性和耦合度。

通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保 证实体只有一个引起它变化的原因。

专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将 使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。

**开放封闭原则（Open-Closed principle）**

其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修 改封闭的。

开放封闭原则主要体现在两个方面：

1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的 情况。 2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任 何尝试的修改。

实现开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。 让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。

“需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求， 同时还能保持软件内部的封装体系稳定，不被需求的变化影响。

**Liskov 替换原则（Liskov-Substitution Principle）**

其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只 有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。

在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子 类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基 类，但是基类不一定能替换子类。

Liskov 替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循 Liskov 替换原则，才能保证继承复用是可靠地。

实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过 Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。 Liskov 替换原则是关于继承机制的设计原则，违反了 Liskov 替换原则就必然导致违反开放封闭原 则。 Liskov 替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能 够减少代码冗余，避免运行期的类型判别。

**依赖倒置原则（Dependecy-Inversion Principle）**

其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖 于抽象；抽象不依赖于具体，具体依赖于抽象。

我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦 合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块 调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计 目标。

抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的 精髓，也是依赖倒置原则的核心。 依赖于抽象是一个通用的原则，而某些时候依赖于细节 则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象， 就是对接口编程，不要对实现编程。

**接口隔离原则（Interface-Segregation Principle）**

其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。

具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对 另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。

接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单 一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等； 而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这 会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种 灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们 的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。

分离的手段主要有以下两种：

1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖， 但是会增加系统的开销。 2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。