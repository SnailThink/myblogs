 ## 复盘基础内容



## 1.SpringBoot



#### 1.SpringBoot自动装配




- ```java
  @SpringBootApplication 标注是一个springboot的应用 
  ```

- ```java
  @SpringBootConfiguration   springboot的配置
  @Configuration   spring的配置类
  @Component   说明这也是一个spring的组件
  @EnableAutoConfiguration   开启自动配置
  @AutoConfigurationPackage  自动配置包
  @Import(AutoConfigurationPackages.Registrar.class)  导入选择器
  @Import(AutoConfigurationImportSelector.class)   导入选择器
  List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes); 获取所有的配置
  ```
  
- ```java
  //获取所有的配置
  protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
     List<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
           getBeanClassLoader());
     Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you "
           + "are using a custom packaging, make sure that file is correct.");
     return configurations;
  }
  
  protected Class<?> getSpringFactoriesLoaderFactoryClass() {
  		return EnableAutoConfiguration.class;
  	}
  ```
  
- META-INF/spring.factories  自动配置的核心文件
  

![](https://whcoding.oss-cn-hangzhou.aliyuncs.com/img/20220401182242.png)

spring-factories 存放的都是自动配置类的名称，主程序启动时候就通过注解将自动配置类全部加载，有了这些配置类就省去写配置文件.



[springboot自动装配](https://juejin.cn/post/6939520188823896100)

[springboot原理解析](https://juejin.cn/post/6939470264853889061#heading-19)

#### 2.SpringMVC 初始化流程分析



 ## 2. 集合

 #### 2.2.1 Arraylist 与 LinkedList 区别?

1.  是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；
2. **底层数据结构：** `Arraylist` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。
3. **插入和删除是否受元素位置的影响：** ① **`ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。** 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② **`LinkedList` 采用链表存储，所以对于`add(E e)`方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置`i`插入和删除元素的话（`(add(int index, E element)`） 时间复杂度近似为`o(n))`因为需要先移动到指定位置再插入。**
4. **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList` 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。
5. **内存空间占用：** ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。
6. LinkedList 言插入删除操作很快，但是查询操作很慢



#### 2.2.2. 如何选用集合?

需要排序时选择 `TreeMap`,不需要排序时就选择 `HashMap`,需要保证线程安全就选用 `ConcurrentHashMap`。

当我们只需要存放元素值时，就选择实现`Collection` 接口的集合，需要保证元素唯一时选择实现 `Set` 接口的集合比如 `TreeSet` 或 `HashSet`，不需要就选择实现 `List` 接口的比如 `ArrayList` 或 `LinkedList`，然后再根据实现这些接


#### 2.2.3 HashSet、LinkedHashSet 和 TreeSet 三者的异同

`HashSet` 是 `Set` 接口的主要实现类 ，`HashSet` 的底层是 `HashMap`，线程不安全的，可以存储 null 值；

`LinkedHashSet` 是 `HashSet` 的子类，能够按照添加的顺序遍历；

`TreeSet` 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。