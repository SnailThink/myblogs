## MySQL编码规范

## 1. 概述

### 1.1.基本原则

- 使用有意义的英文词汇，词汇中间以下划线分隔，不要使用拼音。

- 库、表、字段全部采用小写，不要使用驼峰式命名。

- 避免用保留关键字。

- 命名不超过32个字符，须见名知意。

- 数据库，数据表根据模块使用前缀。

- 临时库、表名以tmp为前缀，并以日期为后缀。

- 备份库、表以bak为前缀，并以日期为后缀。

## 2. 对象命名

### 2.1. 数据库

### 2.2. 表命名

同一个模块的表尽可能使用相同的前缀，表名称尽可能表达含义。

如所有日志表均以 log_ 开头  

### 2.3. 字段命名

表达其实际含义的英文单词或简写。

相同字段在不同表的命名一致。

外键字段命名为：表名关键字_字段名。

### 2.4. 索引命名

非唯一索引命名：idx_表名_字段名。

唯一索引命名：uni_表名_字段名。

### 2.5. 约束命名

主键约束：pk_表名称_字段名。

唯一约束：uk_表名称_字段名。

### 2.6. 触发器命名

tri_表名_操作，操作为：ins、upd、del。

### 2.7. 函数命名

前缀：fn_业务描述|表名_操作,操作为：ins、upd、del。

### 2.8. 存储过程命名

前缀：pr_业务描述|表名_操作,操作为：ins、upd、del。

### 2.8. 序列命名

seq_表名。

## 3. 库表基本规范

### 3.1．默认使用InnoDB引擎

### 3.2．表字符集统一使用UTF8

UTF8字符集存储汉字占用3个字节，存储英文字符占用1个字节。

校对字符集使用默认的 utf8_general_ci。

连接的客户端也使用utf8，建立连接时指定charset或SET NAMES UTF8。

### 3.3．适度使用存储过程、视图，禁止使用触发器、事件

## 4. 表基本规范

### 4.1．所有表必须要显式指定主键

主键尽量采用自增方式，少数情况如频繁查询多个字段，可以考虑使用联合唯一主键，需与DBA协商。

### 4.2．慎用外键

因为新纪录会去主键表做校验，影响性能。

在应用层实现外键约束。

### 4.3．所有表和字段都要添加注释

使用 comment 列属性来描述此表、字段所代表的真正含义，如是枚举值则建议将该字段中使用的内容都定义出来。

### 4.4．控制单表字段数量

单表字段数上限30个左右，再多的话考虑垂直分表。

考虑原则：1.冷热数据分离，2.大字段分离，3.常在一起做条件和返回列的不分离。

表字段控制少而精，可以提高IO效率，内存缓存更多有效数据，从而提高响应速度和并发能力。

### 4.5．单表数据量控制在5000w以内

考虑分库分表



### 4.6．表行记录物理长度尽量不超过8KB

InnoDB的data page默认是16KB一个data page中需要至少存储2条记录。当实际存储长度超过8KB（尤其是TEXT/BLOB列）的大列时会引起页溢出。

如果必须使用大列（尤其是TEXT/BLOB类型）且读写频繁的话，最好把这些列拆分到子表中，不要和主表放在一起存储。如果不太频繁，可以考虑继续保留在主表中。

### 4.7．避免在数据库中存储图片，视频和文件等二进制数据

该类数据存储在相应服务器中，数据库只存储指针数据。

### 4.8．数据库中不允许存储明文密码

密码经过加密后存储。

## 5. 字段规范

### 5.1. 建议字段都定义为NOT NULL

索引字段一定要定义为not null，因为null值会影响优化器对索引的选择。

如不确定是否有值则定义时使用default ‘’，或 0。

### 5.2. 所有存储相同数据的字段名和字段类型必须一致

如不同表中都有 vehicle_id字段，那么它的名称、类型、字段长度要相同。

### 5.3．优先选择符合存储需要的最小的数据类型

- char：适合长度固定且更新频繁的字段；

- varchar：UTF8最多能存储28144个汉字，65532个英文；

- varbinary(M)：以字节保存二进制字符串，无关字符集，M长度0~255,只适用于排序或比较时大小写敏感的类型

- text：最大长度2^16个字节，一般用于存放容量平均都很大、操作没有其它字段那样频繁的值。

- blob是varbinary扩展，存储字节。

- 建议使用 UNSIGNED 存储非负数值，无符号值取值范围:UNSIGNED INT (0--4294967295)

- 使用tinyint来代替 enum和boolean

ENUM类型在需要修改或增加枚举值时，需要在线DDL，成本较高；ENUM列值如果含有数字类型，可能会引起默认值混淆。

而tinyint使用1个字节，一般用于status,type,flag的列。

- 使用Decimal 代替float/double存储精确浮点数

- 优先使用timestamp，datetime也没问题

datetime 占用8个字节，timestamp 4个字节，前者范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59，后者范围为 1970-01-01 08:00:01 到 2038-01-19 11:14:07。

timestamp可以在insert/update行时，自动更新时间字段（如 f_set_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP），但一个表只能有一个这样的定义。



### 5.4. 尽量避免使用字符串存储日期型数据

### 5.5. 使用TIMESTAMP或DATATIME类型存储时间

## 6. 索引规范

### 6.1．限制每张表的索引数量，建议单表索引数量不超过5个或不超过表字段个数的20%

### 6.2. 禁止给表中的每一列都建立单独的索引,单个索引中的字段数不超过5个

### 6.3. 为经常需要排序、分组和联合操作的字段建立索引

建议：

SELECT,UPDATE,DELETE语句的WHERE从句中的列。

包含在ORDER BY,GROUP BY,DISTINCT中的字段。

多表JOIN的关联列。

尽量选择区分度高的列作为索引。

### 避免建立冗余索引和重复索引

(a,b,c)、(a,b)，后者为冗余索引。

可以利用前缀索引来达到加速目的，减轻维护负担。

### 对于频繁的查询优先考虑使用覆盖索引

避免进行索引的二次查找。

## 7. SQL设计规范

### 7.1. 禁止使用select *进行查询及没有字段列表的insert操作

### 7.2. 程序连接不同的数据库使用不同的账号，禁止跨库查询

### 7.3. 禁止在where条件列上使用函数

对列进行函数转换或计算会导致无法使用索引

where date(createtime)='20160901'

改进:

 where createtime >= '20160901' and createtime < '20160902'

### 7.4. 使用不等于（!= 或者 <>），无法使用索引

### 7.5. 使用like模糊匹配，%不要放首位

### 7.6. 少用子查询，改用join

### 7.7. 充分利用前缀索引

### 7.8. 考虑使用union all，少使用union，注意考虑去重

UNION会把所有数据放到临时表中后再进行去重操作。

UNION ALL不会再对结果集进行去重操作。

### 7.9. 避免隐式转换,会导致索引失效

## 8. 参考

http://blog.itpub.net/15498/viewspace-2134365

https://www.jianshu.com/p/c626c7ad27bf

http://blog.51cto.com/wangwei007/1709769